* 参考资料
    * (MIPS 通用寄存器)[https://e-mailky.github.io/2017-02-14-mips-registers]
    * (MIPS32寄存器详解)[https://www.cnblogs.com/justin-y-lin/p/15010301.html]
    * https://binhack.readthedocs.io/zh/latest/assembly/mips.html
# 寄存器
* 通用寄存器
    * `$0`(`$zero`): 常量0(constant value 0)
        * 为0这个有用常数提供了一个简洁的编码形式. 
    * `$1`(`$at`): 保留给汇编器(Reserved for assembler)
        * 加载大常数时, 编译器需要把大常数拆开, 然后重新组合到寄存器里. 汇编程序必需一个临时寄存器来重组大常数. 
    * `$2-$3`(`$v0-$v1`): 函数调用返回值(values for results and expression evaluation)
        * 存放一个子程序(函数)的非浮点运算的结果或者返回值, 如果这两个寄存器不够存放需要返回的值, 则通过内存完成. 
    * `$4-$7`(`$a0-$a3`): 函数调用参数(arguments)
        * 用于传递前四个参数给子程序, 不够的用栈
    * `$8-$15`(`$t0-$t7`): 临时寄存器
    * `$16-$23`(`$s0-$s7`): 保存寄存器(如果用, 需要`SAVE`/`RESTORE`的)
        * 在过程调用过程中需要保留(被调用者保存和恢复, 其他还有`$fp`和`$ra`)
        * MIPS 提供了临时寄存器和保存寄存器, 这样就减少了寄存器溢出(`spilling`,即将不常用的变量放到存储器的过程). 
        * 编译器在编译一个叶过程(不调用其它过程的过程)的时候, 总是在临时寄存器分配完了才使用需要保存寄存器
    * `$24-$25`(`$t8-$t9`): 临时寄存器
    * `$26-$27`(`$k0-$k1`): 异常或者中断处理程序使用
    * `$28`(`$gp`): 全局指针(Global Pointer)
        * 指向静态数据区
        * 上下32KB范围
    * `$29`(`$sp`): 栈指针(Stack Pointer)
    * `$30`(`$fp`): 帧指针(Frame Pointer)
    * `$31`(`$ra`): 返回地址(return address)
        * 例如调用程序把参数放到`$a0~$a3`, 然后`jal X`跳到X过程, 被调过程完成后把结果放到`$v0,$v1`,然后使用`jr $ra`返回. 
* 协处理器0寄存器(CP0)
    * `EPC`(异常程序计数器)(exception program counter,)
        * 用于保存造成异常的那条指令的地址, 异常处理结束后通过`jr`指令调回来继续执行. 
    * 操作: 
        * 写CP0寄存器: 
            * `mtc0 s, <n>`: 把CPU通用寄存器s的值写入CP0寄存器n中. 
            * 当MIPS刚问世时, 最多可以支持32个CP0寄存器, 但是后续的MIPS32/64最多可以支持256个CP0寄存器. 为了保持指令向前兼容, 通过在CP0寄存器号(实际上是指令中以前编码为0的域)后附加3位的. `select域`来实现. 这样就出现了`CP0 12.1`这种写法的寄存器, 访问方式如下: 
                * `mtc0 s, $12, 1`: 把CPU通用寄存器s的值写入CP0寄存器12.1中
        * 读CP0寄存器: 
            * `mfc0 d, <n>`: 从CP0寄存器n取值写入CPU通用寄存器d中